import axios from "axios";

/**This file holds helper functions that help with sending http requests to the 
backend.
By default all data i.e new resources as adding, updating, deleting 
expenses are saved locally in our context API.We used Firebase as backend
and we created a realtime database.*/

const BACKEND_URL =
  "https://react-native-course-b1a83-default-rtdb.firebaseio.com";

/**When making a post request Firebase will create ID for each
  new resource added so we must get this ID on the response object  */
export async function storeExpense(expenseData) {
  /**Here we used the POST request fro creating new data.So the post method
    of axios helps us send such a request, and now we need to pass the URL to 
    which the request should be sent as a string, as a first argument to post.
    And the URL is the URL provided by Firebase when you created the database.
    After the root URL, we can add more segments, for example, expenses.json.
    Now this .json part is Firebase  specific has nothing to do with react native 
    or react or anything like this.Firebase just wants this .json at the end here 
    to understand that we're targeting a specific node in the database.You can add 
    any segments you want here.And those segments will be translated as nodes or to
    folders you could say in the database.So this will create an expenses node in this 
    database.Now, as a second argument to the post method we have to define the value
    that should be sent which I expect to be an object that holds the amount, description 
    and date.Not the ID, because an ID, a unique ID will be auto-generated by the Firebase
    which is pretty convenient because that allows us to get rid of our custom pseudo unique 
    ID generation*/
  const response = await axios.post(
    BACKEND_URL + "/expenses.json",
    expenseData
  );

  /**The next line will get the ID holds in data property, but the auto generated ID is not 
  called ID, it is a name property that holds the auto-generated ID. */
  const id = response.data.name;

  /**So our storeExpense function returns a promise because it's async, which will then resolve 
  to the returned ID in the end. */
  return id;
}

/**Sending an http request is an asynchronous task.That means it doesn't 
  complete immediately.That's why post and get return promises which is not 
  React Native specific, it's a javaScript concept.In short, a promise
  is an object that will eventually give you access to some other data.And here, get, for
  example, will eventually give us access to the data fetched from the backend.
  Now to work with promises, we can add then on the promise object, and then pass a function
  to then, which will be called once the eventual data is there.Or alternatively, we can use 
  async-await, which is a more modern javaScript feature to write promises easily.*/

export async function fetchExpenses() {
  /**With the async we can await this promise and store the eventually returned data, which in 
  this case will be a response object with more details about the response in a constant named 
  response.So that's how we can use async-await here.*/
  const response = await axios.get(BACKEND_URL + "/expenses.json");

  /**The following line will only execute once the response is there, so once we have the response 
  from the server, and then we can use this response.Now, when it comes to using the response, for 
  Firebase, the response we get back will be an object where unique IDs will be keys, so properties 
  names in that object, and if we had multiple expenses, we would have multiple property names.And
  then will have nested objects for these keys, for these unique IDs, that hold the actual data.And
  I wanna transform that data into an array of objects where every object has the ID in an ID field,
  and the amount, date and description in other separate fields.*/
  const expenses = [];

  //console.log(response.data);
  /**Axios gives us a data property on this response object which holds the actual data that was sent back 
  by the server.So now we go through all the keys in that object, because we will get back an object.And those 
  keys will therefore be those IDs. */
  for (const key in response.data) {
    const expenseObj = {
      id: key,
      amount:
        response.data[key]
          .amount /**Now, this syntax here simply means that we dynamically access a property
      which name is stored in that key constant. */,
      date: new Date(
        response.data[key].date
      ) /**I wanna transform the date to a date object by passing it to the 
      date constructor because Firebase stores the date as a string and I wanna convert it back into a date object
      because we work with that date object on the front end.*/,
      description: response.data[key].description,
    };
    expenses.push(expenseObj);
  }
  /**At the end this code will simply transform the data sent back from Firebase into an array of
  objects that have the format we want them to have.*/
  return expenses;
}

export function updateExpense(id, expenseData) {
  /**Here to updating we wanna target one specific
  expense.And when working with Firebase and the rest API
  exposed by it, we bind the ID of the expense of the target 
  into this URL.Here we get removed the async because we won't 
  sue tha await word and I'm just returning the promise with 
  the return statement. */
  return axios.put(BACKEND_URL + `/expenses/${id}.json`, expenseData);
}

/**We don't need the async keyword there either, because I will also
just return the result of calling axios delete method, which will 
send a delete request to a given URL.*/
export function deleteExpense(id) {
  return axios.delete(BACKEND_URL + `/expenses/${id}.json`);
}
